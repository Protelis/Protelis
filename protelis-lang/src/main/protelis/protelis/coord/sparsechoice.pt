module protelis:coord:sparsechoice
import protelis:coord:spreading
import java.lang.Double.POSITIVE_INFINITY

def default() {
    [POSITIVE_INFINITY, POSITIVE_INFINITY]
}

def breakUsingUids(uid, grain, metric) {
    share (lead, nbrLead <- uid) {
        distanceCompetition(distanceToWithMetric(uid == lead, metric), nbrLead, uid, grain)
    } == uid
}

def distanceCompetition(d, nbrLead, uid, grain) {
    mux (d > grain) {
        uid
    } else {
        let thr = 0.25 * grain;
        mux (d >= thr) {
            default()
        } else {
            mux (d >= thr) {
                default()
            } else {
                minHood PlusSelf(nbrLead)
            }
        }
    }
}

def randomUid() {
    rep (v <- [self.nextRandomDouble(), self.getDeviceUID()]) {
        v
    }
}

def idOf(tuple) = tuple.get(0)
def distanceOf(tuple) = tuple.get(1).get(1)
def tieBreakerOf(tuple) = [tuple.get(1).get(0), tuple.get(0)]

/**
 * Devices compete against one another to become local leaders,
 * resulting  in  a  random  Voronoi  partition  with  a  characteristic
 * grain size.
 * This implementation leverages [processes](https://doi.org/10.1016/j.engappai.2020.104081),
 * each device tries to propagate a "bubble of influence", overlapping bubbles compete,
 * the highest symmetryBreaker value of the competing participants is selected.
 *
 * @param uid  T, unique node identifier
 * @param symmetryBreaker  V, competitivity, higher values make their node a more likely leader. Must be Comparable<V>.
 * @param grain  num, maximum radius of the partition
 * @param metric () -> num, neighbor distance estimator, returns a field of numbers
 * @param distance (bool) -> num, finds the distance with the closest location where the provided input is true
 * @return  T, the id of the local leader
 */
public def localLeaderElection(uid, symmetryBreaker, grain, metric, distance) {
	let default = [uid, [symmetryBreaker, 0]]
	share (lead, nbrLead <- default) {
		let sources = [nbrLead]
		let distances = alignedMap(
			sources,
			{ candidate, breakDist ->
				candidate == uid || foldMin(POSITIVE_INFINITY, breakDist.get(1) + metric()) < grain
			},
			{ candidate, breakDist ->
				[foldMax(breakDist.get(0)), distance(uid == candidate && idOf(lead) == uid)]
			},
			[NEGATIVE_INFINITY, POSITIVE_INFINITY]
		)
		let closeEnough = distances.filter { distanceOf(it) < grain }
		let best = closeEnough.fold(default) { a, b ->
			if (tieBreakerOf(a) > tieBreakerOf(b)) { a } else { b }
		}
		best
	}.get(0)
}

/**
 * Devices compete against one another to become local leaders,
 * resulting  in  a  random  Voronoi  partition  with  a  characteristic
 * grain size.
 *
 * @param grain  num, partition dimension
 * @param metric () -> num, estimate distance from the leader
 * @return       bool, true if the current device is the leader, false otherwise
 */
public def S(grain, metric) {
    breakUsingUids(randomUid(), grain, metric)
}

